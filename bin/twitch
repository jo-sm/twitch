#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'json'
require 'open-uri'
require 'fileutils'
require 'time'
require 'optparse'

options = {}

OptionParser.new do |opt|
  opt.on('--limit [LIMIT]', Integer, 'Video limit, default 30') { |o| options[:limit] = o }
  opt.on('--player PLAYER_NAME', 'Video player, default QuickTime.') { |o| options[:player] = o }
end.parse!

options[:limit] or options[:limit] = 30
options[:player] or options[:player] = 'QuickTime Player'

abort "Error: Please supply a mode. Usage: twitch {live,vod} BROADCASTER" if !ARGV[0]
abort "Error: Please supply a broadcaster. Usage: twitch {live,vod} BROADCASTER" if !ARGV[1]

def api(raw_uri, error_msg)
  client_id = 'jzkbprff40iqj646a697cyrvl0zt2m6'

  uri = URI.parse(raw_uri)

  begin
    uri.open({
      'Client-ID' => client_id
    }).read
  rescue OpenURI::HTTPError => e
    abort "#{error_msg} (#{e})"
  end
end

def get_token(type, opts) 
  suffix = '/access_token?adblock=false&need_https=true&platform=web&player_type=site'

  if type == 'live'
    token_url = "https://api.twitch.tv/api/channels/#{opts["broadcaster"]}#{suffix}"
  elsif type == 'vod'
    token_url = "https://api.twitch.tv/api/vods/#{opts["video_id"]}#{suffix}"
  end

  raw_token = api(token_url, "Error: Unable to retrieve token")
  token = JSON.parse(raw_token)

  raise "Error: #{token["message"]}" if token["error"]

  token
end

def get_stream_url(type, token, opts)
  if type == 'live'
    params = {
      'token' => URI.escape(token["token"]),
      'sig' => URI.escape(token["sig"])
    }

    streams_url = "http://usher.justin.tv/api/channel/hls/#{opts["broadcaster"]}.m3u8"
  elsif type == 'vod'
    params = {
      :nauth => URI.escape(token["token"]),
      :nauthsig => URI.escape(token["sig"]),
      :allow_source => true,
      :allow_spectre => true,
      :p => Random.rand(1000000..9999999),
      :baking_bread => true
    }

    streams_url = "https://usher.ttvnw.net/vod/#{opts["video_id"]}.m3u8"
  end

  url = "#{streams_url}?#{params.reduce([]) { |memo,(k,v)| memo.push("#{k}=#{v}") }.join('&')}"

  raw = api(url, "Error: Stream is not live")
  streams = raw.split("\n")

  skip = false
  sources = {}

  streams.each_with_index do |line, i| 
      if skip
          skip = false
          next
      end

      if line.start_with? "#EXT-X-STREAM-INF:"
          values = line[18..-1].split('=').map { |p| 
              p.split(',') 
          }.reduce([]) { |memo, i| 
              if i.length == 1
                  if memo.length == 0
                      memo.push(i)
                  else
                      memo[-1].push(i)
                  end
              else
                  memo[-1].push(i[0..-2])
                  memo.push([i[-1]])
              end

              memo
          }.reduce({}) { |memo, i|
              name = i[0].downcase.split('-').join('_').to_sym
              memo[name] = i[1..-1].join(',')

              memo
          }

          sources[values[:video]] = {
              :video => values[:video].gsub('"', ''),
              :url => streams[i+1],
              :resolution => values[:resolution],
              :bandwidth => values[:bandwidth]
          }

          skip = true
          next
      end
  end

  # Get the source with the highest bandwidth
  source = sources.values.max_by { |source| source[:bandwidth].to_i }
  bandwidth = (source[:bandwidth].to_f / 1000).round(2)
  unit = 'kb'

  if bandwidth > 1000
    bandwidth = (bandwidth / 1000).round(2)
    unit = 'mb'
  end

  puts "Playing quality: #{source[:video]} @ #{bandwidth} #{unit}/s"

  source[:url]
end

def watch(url, options)
  # Attempt to open with the open command, since it may be a GUI program
  `open -a "#{options[:player]}" "#{url}" 2>/dev/null`

  if $? != 0 and options[:player] != "QuickTime Player"
    # Attempt to run as a command line program
    # This may affect how the process is seen by Activity Monitor (
    # may be seen as a child of the bash process)
    pid=`#{options[:player]} "#{url}" 2&>1 &`

    puts pid

    if $? != 0
      puts "For some reason, the player couldn't be opened properly. Try running 'twitch' without the player argument."
    end
  end
end

def add_to_broadcasters_cache(broadcaster)
  config_home = File.join(Dir.home, ".twitch")
  broadcaster_cache_file = File.join(config_home, "broadcaster_cache")

  begin
    Dir.mkdir(config_home, 0755)
  rescue Errno::EEXIST
  end

  FileUtils.touch(broadcaster_cache_file)

  cache_file = open(broadcaster_cache_file, 'r')
  cache = cache_file.read
  cache_file.close

  begin
    cache = JSON.parse(cache)
  rescue JSON::ParserError
    cache = []
  end

  cache << broadcaster

  cache.uniq!

  cache_file = open(broadcaster_cache_file, 'w')
  JSON.dump(cache, cache_file)
  cache_file.close
end

def main(options)
  mode = ARGV[0]
  broadcaster = ARGV[1].downcase

  if mode == 'live'
    token = get_token('live', { "broadcaster" => broadcaster })
    stream_url = get_stream_url('live', token, { "broadcaster" => broadcaster })
    add_to_broadcasters_cache broadcaster
    watch stream_url, options
  elsif mode === 'vod'
    videos = api("https://api.twitch.tv/kraken/channels/#{broadcaster}/videos?broadcasts=true&limit=#{options[:limit]}", "Error: Broadcaster does not exist")
    videos_list = JSON.parse(videos)

    abort "Error: Broadcaster has no saved broadcasts" if videos_list["videos"].length == 0

    videos_list["videos"].each_with_index do |video, i|
      time = Time.parse(video["recorded_at"]).getlocal.strftime('%a %b %e %Y %l:%M%p')
      puts "#{i+1}: (#{time}) #{video["title"]}"
    end

    print "Please select the video you would like to watch: "
    index = $stdin.gets.strip.to_i

    while !videos_list["videos"][index-1] or (index < 1)
      puts "Error: Invalid selection"
      print "Please select the video you would like to watch: "
      index = $stdin.gets.strip.to_i
    end

    video_id = videos_list["videos"][index-1]["_id"][1..-1]
    token = get_token('vod', { "video_id" => video_id })
    stream_url = get_stream_url('vod', token, { "video_id" => video_id })

    add_to_broadcasters_cache broadcaster

    watch stream_url, options
  else
    abort "Error: Invalid mode supplied. Valid modes are: live, vod. Usage: twitch {live,vod} BROADCASTER"
  end
end

begin
  main(options)
rescue SystemExit, Interrupt
  puts ""
  exit
end
