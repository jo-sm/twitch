#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'json'
require 'open-uri'

abort "Error: Please supply a mode. Usage: twitch {live,vod} BROADCASTER" if !ARGV[0]
abort "Error: Please supply a broadcaster. Usage: twitch {live,vod} BROADCASTER" if !ARGV[1]

mode = ARGV[0]
broadcaster = ARGV[1].downcase

def get_token(type, opts) 
  if type == 'live'
    token_url = "https://api.twitch.tv/api/channels/#{opts["broadcaster"]}/access_token?on_site=1"
  elsif type == 'vod'
    token_url = "https://api.twitch.tv/api/vods/#{opts["video_id"]}/access_token?on_site=1"
  end

  begin
    raw_token = URI.parse(token_url).read
    token = JSON.parse(raw_token)
  rescue OpenURI::HTTPError
    abort "Error: Unable to retrieve token"
  end

  raise "Error: #{token["message"]}" if token["error"]

  token
end

def get_stream_url(type, token, opts)
  if type == 'live'
    streams_url = "http://usher.justin.tv/api/channel/hls/#{opts["broadcaster"]}.m3u8?token=#{URI.escape(token["token"])}&sig=#{URI.escape(token["sig"])}"
  elsif type == 'vod'
    streams_url = "http://usher.justin.tv/vod/#{opts["video_id"]}?nauth=#{URI.escape(token["token"])}&nauthsig=#{URI.escape(token["sig"])}"
  end

  streams = Net::HTTP.get_response(URI(streams_url))
  abort "Error: Stream is not live" if streams.is_a? Net::HTTPNotFound

  stream_info = {}
  current_stream = ''

  streams.body.split("\n").each do |line| 
    # Stream information
    if line.start_with? "#EXT-X-STREAM-INF:"
      _hash = {}

      # PROGRAM-ID=1,BANDWIDTH=928000,VIDEO="medium"
      split = line[18..-1].split(',').each do |info|
        part = info.split('=')
        if part[0] == "BANDWIDTH"
          _hash["bandwidth"] = "#{part[1].to_i / 1000} kb/s"
        elsif part[0] == "VIDEO"
          _hash["format"] = part[1]
          current_stream = part[1]
        end
      end
      
      stream_info[current_stream] = {}
      stream_info[current_stream]["bandwidth"] = _hash["bandwidth"]
      stream_info[current_stream]["format"] = _hash["format"]
      
    elsif !line.start_with? "#"
      stream_info[current_stream]["url"] = line
    end
  end

  puts stream_info
  if stream_info['"chunked"']
    puts "Quality: chunked"
    stream_info['"chunked"']["url"]
  elsif stream_info['"high"']
    puts "Quality: high"
    stream_info['"high"']["url"]
  else
    # Just choose one
    key, val = stream_info.first
    puts "Quality: #{key}"
    val["url"]
  end
end

def watch(url)
  `open -a "QuickTime Player" "#{url}"`
end

if mode == 'live'
  token = get_token('live', { "broadcaster" => broadcaster })
  stream_url = get_stream_url('live', token, { "broadcaster" => broadcaster })
  watch stream_url
elsif mode === 'vod'
  begin
    videos = URI.parse("https://api.twitch.tv/kraken/channels/#{broadcaster}/videos?broadcasts=true").read
  rescue OpenURI::HTTPError
    abort "Error: Broadcaster does not exist"
  end

  videos_list = JSON.parse(videos)

  abort "Error: Broadcaster has no saved broadcasts" if videos_list["videos"].length == 0

  videos_list["videos"].each_with_index do |video, i|
    puts "#{i+1}: #{video["title"]}"
  end

  print "Please select the video you would like to watch: "
  index = $stdin.gets.strip.to_i

  # TODO: handle pagination
  while !videos_list["videos"][index-1] or (index < 1)
    puts "Error: Invalid selection"
    print "Please select the video you would like to watch: "
    index = $stdin.gets.strip.to_i
  end

  video_id = videos_list["videos"][index-1]["_id"][1..-1]
  token = get_token('vod', { "video_id" => video_id })
  stream_url = get_stream_url('vod', token, { "video_id" => video_id })

  watch stream_url
else
  abort "Error: Invalid mode supplied. Valid modes are: live, vod. Usage: twitch {live,vod} BROADCASTER"
end
